spring:
  servlet:
    multipart:
      max-file-size: 10MB
      max-request-size: 10MB
  cloud:
    gateway:
      globalcors:
        cors-configurations:
          '[/**]':
            exposedHeaders: 
              - "Filename"
              - "Content-Disposition"
            allowedOrigins:
              - "http://localhost"
            allowedMethods:
              - GET
              - POST
              - PUT
              - DELETE
              - OPTIONS
            allowedHeaders: "*"
            allowCredentials: true
    kubernetes:
      discovery:
        enabled: true
      loadbalancer:
        mode: POD
    loadbalancer:
      cache:
        enabled: true 
        ttl: 5s
        capacity: 256
    gateway:
      server:
        webflux:
          routes:
            - id: users_auth
              uri: lb://users
              predicates:
                - Path=/api/v1/users/**
                - Header=Authorization, Bearer .*
              filters:
                - RewritePath=/api/v1/users(/?)(?<segment>.*), /$\{segment}
                - name: Retry
                  args:
                    retries: 3
                    statuses: BAD_GATEWAY
                    methods: GET,POST,PUT,DELETE
                    backoff:
                      firstBackoff: 20ms
                      maxBackoff: 100ms
                      factor: 2
                      basedOnPreviousValue: false
                - name: CircuitBreaker
                  args:
                    name: users
                - name: RequestRateLimiter
                  args:
                    redis-rate-limiter:
                      replenishRate: 120
                      burstCapacity: 20
                      requestedTokens: 1
                      key-resolver: #{@keyResolver}
            - id: users
              uri: lb://users
              predicates:
                - Path=/api/v1/users/**
              filters:
                - RewritePath=/api/v1/users(/?)(?<segment>.*), /$\{segment}
                - name: Retry
                  args:
                    retries: 2
                    statuses: BAD_GATEWAY
                    methods: GET,POST,PUT,DELETE
                    backoff:
                      firstBackoff: 20ms
                      maxBackoff: 100ms
                      factor: 2
                      basedOnPreviousValue: false
                - name: CircuitBreaker
                  args:
                    name: users
                - name: RequestRateLimiter
                  args:
                    redis-rate-limiter:
                      replenishRate: 10
                      burstCapacity: 20
                      requestedTokens: 1
                      key-resolver: #{@keyResolver}
  data:
    redis:
      connect-timeout: 2s
      host: redis
      port: 6379
      password: root
      timeout: 1s

app:
  security:
    jwt:
      secret: U29tZVNlY3JldEtleU5lZWRzVG9CZUF0TGVhc3QzMkJ5dGVz

logging:
  loki:
    url: http://loki:3100/loki/api/v1/push

logbook:
  exclude: /actuator/**
  logbook:
    format: 
      style: http

management:
  endpoints:
    web:
      exposure:
        include: '*'
  health:
    circuitbreakers:
      enabled: true
    ratelimiters:
      enabled: true
  endpoint:
    gateway:
      access: read-only
    health:
      show-details: always
      show-components: always
    prometheus:
      access: read_only
  tracing:
    sampling:
      probability: 0.2
  otlp:
    tracing:
      endpoint: http://tempo:4317 
      transport: grpc
      timeout: 30s

resilience4j:
  timelimiter:
    configs:
      default:
        timeout-duration: 20s
        cancel-running-future: true
  circuitbreaker:
    instances:
      users:
        slidingWindowType: COUNT_BASED
        slidingWindowSize: 4
        waitDurationInOpenState: 10s
        failureRateThreshold: 50
        eventConsumerBufferSize: 10
        registerHealthIndicator: true
        permittedNumberOfCallsInHalfOpenState: 5
  thread-pool-bulkhead:
    instances:
      users:
        maxThreadPoolSize: 60
        coreThreadPoolSize: 10
        queueCapacity: 20
        writableStackTraceEnabled: true

# resilience4j.circuitbreaker.instances.extractions.slidingWindowType=COUNT_BASED
# resilience4j.circuitbreaker.instances.extractions.slidingWindowSize=4
# resilience4j.circuitbreaker.instances.extractions.waitDurationInOpenState=10s
# resilience4j.circuitbreaker.instances.extractions.failureRateThreshold=50
# resilience4j.circuitbreaker.instances.extractions.eventConsumerBufferSize=10
# resilience4j.circuitbreaker.instances.extractions.registerHealthIndicator=true
# resilience4j.circuitbreaker.instances.extractions.permittedNumberOfCallsInHalfOpenState=5

# resilience4j.thread-pool-bulkhead.instances.extractions.maxThreadPoolSize=30
# resilience4j.thread-pool-bulkhead.instances.extractions.coreThreadPoolSize=5
# resilience4j.thread-pool-bulkhead.instances.extractions.queueCapacity=15
# resilience4j.thread-pool-bulkhead.instances.extractions.writableStackTraceEnabled=true

# resilience4j.circuitbreaker.instances.extractions-mcp.slidingWindowType=COUNT_BASED
# resilience4j.circuitbreaker.instances.extractions-mcp.slidingWindowSize=4
# resilience4j.circuitbreaker.instances.extractions-mcp.waitDurationInOpenState=10s
# resilience4j.circuitbreaker.instances.extractions-mcp.failureRateThreshold=50
# resilience4j.circuitbreaker.instances.extractions-mcp.eventConsumerBufferSize=10
# resilience4j.circuitbreaker.instances.extractions-mcp.registerHealthIndicator=true
# resilience4j.circuitbreaker.instances.extractions-mcp.permitedNumberOfCallsInHalfOpenState=5

# resilience4j.thread-pool-bulkhead.instances.extractions-mcp.maxThreadPoolSize=30
# resilience4j.thread-pool-bulkhead.instances.extractions-mcp.coreThreadPoolSize=5
# resilience4j.thread-pool-bulkhead.instances.extractions-mcp.queueCapacity=15
# resilience4j.thread-pool-bulkhead.instances.extractions-mcp.writableStackTraceEnabled=true

# resilience4j.circuitbreaker.instances.serverless.slidingWindowType=COUNT_BASED
# resilience4j.circuitbreaker.instances.serverless.slidingWindowSize=4
# resilience4j.circuitbreaker.instances.serverless.waitDurationInOpenState=4s
# resilience4j.circuitbreaker.instances.serverless.failureRateThreshold=50
# resilience4j.circuitbreaker.instances.serverless.eventConsumerBufferSize=10
# resilience4j.circuitbreaker.instances.serverless.registerHealthIndicator=true
# resilience4j.circuitbreaker.instances.serverless.permittedNumberOfCallsInHalfOpenState=5

# resilience4j.thread-pool-bulkhead.instances.serverless.maxThreadPoolSize=30
# resilience4j.thread-pool-bulkhead.instances.serverless.coreThreadPoolSize=5
# resilience4j.thread-pool-bulkhead.instances.serverless.queueCapacity=15
# resilience4j.thread-pool-bulkhead.instances.serverless.writableStackTraceEnabled=true

# spring.cloud.gateway.server.webflux.routes[1].uri=lb://extractions-mcp
# spring.cloud.gateway.server.webflux.routes[1].predicates[0]=Path=/extractions-mcp/**
# spring.cloud.gateway.server.webflux.routes[1].filters[0]=RewritePath=/extractions-mcp/(?!message)(?<segment>.*), /$\{segment}
# spring.cloud.gateway.server.webflux.routes[1].filters[1]=RewritePath=/extractions-mcp/message(?<segment>/?.*), /extractions-mcp/message$\{segment}
# spring.cloud.gateway.server.webflux.routes[1].filters[2].name=Retry
# spring.cloud.gateway.server.webflux.routes[1].filters[2].args.retries=3
# spring.cloud.gateway.server.webflux.routes[1].filters[2].args.statuses=BAD_GATEWAY
# spring.cloud.gateway.server.webflux.routes[1].filters[2].args.methods=GET,POST,PUT,DELETE
# spring.cloud.gateway.server.webflux.routes[1].filters[2].args.backoff.firstBackoff=20ms
# spring.cloud.gateway.server.webflux.routes[1].filters[2].args.backoff.maxBackoff=100ms
# spring.cloud.gateway.server.webflux.routes[1].filters[2].args.backoff.factor=2
# spring.cloud.gateway.server.webflux.routes[1].filters[2].args.backoff.basedOnPreviousValue=false
# spring.cloud.gateway.server.webflux.routes[1].filters[3].name=RequestRateLimiter
# spring.cloud.gateway.server.webflux.routes[1].filters[3].args.redis-rate-limiter.replenishRate=10
# spring.cloud.gateway.server.webflux.routes[1].filters[3].args.redis-rate-limiter.burstCapacity=20
# spring.cloud.gateway.server.webflux.routes[1].filters[3].args.redis-rate-limiter.requestedTokens=1
# spring.cloud.gateway.server.webflux.routes[1].filters[3].args.key-resolver=#{@keyResolver}

# spring.cloud.gateway.server.webflux.routes[2].id=serverless
# spring.cloud.gateway.server.webflux.routes[2].uri=lb://serverless
# spring.cloud.gateway.server.webflux.routes[2].predicates[0]=Path=/serverless/**
# spring.cloud.gateway.server.webflux.routes[2].filters[0]=RewritePath=/serverless(/?)(?<segment>.*), /$\{segment}
# spring.cloud.gateway.server.webflux.routes[2].filters[1].name=Retry
# spring.cloud.gateway.server.webflux.routes[2].filters[1].args.retries=2
# spring.cloud.gateway.server.webflux.routes[2].filters[1].args.statuses=BAD_GATEWAY
# spring.cloud.gateway.server.webflux.routes[2].filters[1].args.methods=GET,POST,PUT,DELETE
# spring.cloud.gateway.server.webflux.routes[2].filters[1].args.backoff.firstBackoff=20ms
# spring.cloud.gateway.server.webflux.routes[2].filters[1].args.backoff.maxBackoff=100ms
# spring.cloud.gateway.server.webflux.routes[2].filters[1].args.backoff.factor=2
# spring.cloud.gateway.server.webflux.routes[2].filters[1].args.backoff.basedOnPreviousValue=false
# spring.cloud.gateway.server.webflux.routes[2].filters[2].name=CircuitBreaker
# spring.cloud.gateway.server.webflux.routes[2].filters[2].args.name=serverless
# spring.cloud.gateway.server.webflux.routes[2].filters[3].name=RequestRateLimiter
# spring.cloud.gateway.server.webflux.routes[2].filters[3].args.redis-rate-limiter.replenishRate=100
# spring.cloud.gateway.server.webflux.routes[2].filters[3].args.redis-rate-limiter.burstCapacity=120
# spring.cloud.gateway.server.webflux.routes[2].filters[3].args.redis-rate-limiter.requestedTokens=1
# spring.cloud.gateway.server.webflux.routes[2].filters[3].args.key-resolver=#{@keyResolver}

# spring.cloud.gateway.server.webflux.routes[3].id=extractions
# spring.cloud.gateway.server.webflux.routes[3].uri=lb://extractions
# spring.cloud.gateway.server.webflux.routes[3].predicates[0]=Path=/extractions/**
# spring.cloud.gateway.server.webflux.routes[3].filters[0]=RewritePath=/extractions(/?)(?<segment>.*), /$\{segment}
# spring.cloud.gateway.server.webflux.routes[3].filters[1].name=Retry
# spring.cloud.gateway.server.webflux.routes[3].filters[1].args.retries=3
# spring.cloud.gateway.server.webflux.routes[3].filters[1].args.statuses=BAD_GATEWAY
# spring.cloud.gateway.server.webflux.routes[3].filters[1].args.methods=GET,POST,PUT,DELETE
# spring.cloud.gateway.server.webflux.routes[3].filters[1].args.backoff.firstBackoff=20ms
# spring.cloud.gateway.server.webflux.routes[3].filters[1].args.backoff.maxBackoff=100ms
# spring.cloud.gateway.server.webflux.routes[3].filters[1].args.backoff.factor=2
# spring.cloud.gateway.server.webflux.routes[3].filters[1].args.backoff.basedOnPreviousValue=false
# spring.cloud.gateway.server.webflux.routes[3].filters[2].name=CircuitBreaker
# spring.cloud.gateway.server.webflux.routes[3].filters[2].args.name=extractions
# spring.cloud.gateway.server.webflux.routes[3].filters[3].name=RequestRateLimiter
# spring.cloud.gateway.server.webflux.routes[3].filters[3].args.redis-rate-limiter.replenishRate=10
# spring.cloud.gateway.server.webflux.routes[3].filters[3].args.redis-rate-limiter.burstCapacity=20
# spring.cloud.gateway.server.webflux.routes[3].filters[3].args.redis-rate-limiter.requestedTokens=1
# spring.cloud.gateway.server.webflux.routes[3].filters[3].args.key-resolver=#{@keyResolver}
